<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    console.log("开始... ");

    // 传统回调写法，容易回调地狱
    // const dbupd = (sql, callback) => {
    //   setTimeout(() => {
    //     console.log(sql + "...耗时2秒");
    //     callback(sql + " ok!");
    //   }, 2000);
    // };
    // dbupd("1.sql", (result) => {
    //   console.log(result);
    //   dbupd("2.sql", (result) => {
    //     console.log(result);
    //     dbupd("3.sql", (result) => {
    //       console.log(result);
    //     });
    //   });
    // });

    // 用Promise来定义异步内容的函数
    const dbupAsync = (sql) => {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                console.log(sql + "...耗时2秒.");
                resolve(sql + " .ok");
            }, 2000);
        });
    };

    // 调用写法A---- then

    // dbupAsync("1.sql")
    //   .then((result) => {
    //     console.log(result);
    //     return dbupAsync("2.sql");
    //   })
    //   .then((result) => {
    //     console.log(result);
    //     return dbupAsync("3.sql");
    //   })
    //   .then((result) => {
    //     console.log(result);
    //   });

    // 写法B -----代码更加简洁的async/await，
    // (async () => {
    //   console.log(await dbupAsync("1.sql"));
    //   console.log(await dbupAsync("2.sql"));
    //   console.log(await dbupAsync("3.sql"));
    // })();

    // 如果需要抽出result来干其他活甚至是传给另外的异步函数，那就写多一点
    (async () => {
        const result1 = await dbupAsync("1.sql");
        console.log(result1);
        const result2 = await dbupAsync("2.sql");
        console.log(result2);
        const result3 = await dbupAsync(result2); // 这里和上面不同特别的吧上一个异步操作的结果给了下一个异步操作
        console.log(result3);
    })();

    console.log("异步定义结束，下面他们开始干活了... ");
</script>
</body>
</html>
